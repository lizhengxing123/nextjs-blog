---
title: '正则表达式'
excerpt: '学习正则表达式'
coverImage: '/assets/blog/javascript/reg.png'
date: '2022-12-04 19:40:08'
author:
  name: 李正星
  picture: '/assets/blog/authors/zx.jpeg'
ogImage:
  url: '/assets/blog/javascript/reg.png'
type: 'Javascript'
---

## 正则表达式

正则表达式是用于匹配字符串中字符组合的模式。在 `JavaScript` 中，正则表达式也是对象。这些模式用于 `RegExp` 的 `exec` 和 `test` 方法，以及 `String` 的 `match`、`matchAll`、`replace`、`search`和`split`方法。

### 创建一个正则表达式

- 使用正则表达式字面量

```js
const reg = /ab+c/
```
> 脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能。

- 调用 `RegExp` 构造函数

```js
const reg = new RegExp("ab+c")
```
> 在脚本运行过程中，用构造函数创建的正则表达式会被编译。如果正则表达式将来会改变，或者它将会从用户的输入等来源中动态的产生，就需要使用构造函数来创建正则表达式。

### 编写正则表达式的模式

一个正则表达式的模式是由简单的字符所构成的。

#### 使用简单模式

简单模式是由你想直接找到的字符构成。比如 `/abc/` 这个模式就能且仅能匹配 `"abc"` 字符按照顺序同时出现的情况。

#### 使用特殊字符

- `\`：在非特殊字符之前表示下一个字符是特殊字符；在特殊字符之前表示下一个字符不是特殊字符
- `^`：匹配输入的开始。如果多行标志被设置为 `true`，那么也会匹配换行符后面紧跟的位置
- `$`：匹配输入的结束。如果多行标志被设置为 `true`，那么也会匹配换行符前的位置
- `*`：匹配前一个表达式 `0` 次或多次，相当于 `{0,}`
- `+`：匹配前一个表达式 `1` 次或多次，相当于 `{1,}`
- `?`：匹配前一个表达式 `0` 次或 `1` 次，相当于 `{0,1}`
> 如果紧跟在任何量词 `* + ? {}` 后面，会使量词变为非贪婪（匹配尽量少的字符），缺省时使用贪婪模式（匹配尽可能多的字符）。比如：
> 对于 `"123abc"`，使用 `/\d+/` 会匹配 `"123"`，而使用 `/\d+?/` 只会匹配 `"1"`
- `.`：（小数点）默认匹配除换行符之外的任何单个字符
- `()`：捕获括号，会匹配括号里面的字符并记住匹配项
- `(?:)`：非捕获括号，会匹配括号里面的字符但不记住匹配项
- `x(?=y)`：先行断言，匹配 `x` 仅当 `x` 后面跟着 `y`
- `(?<=y)x`：后行断言，匹配 `x` 仅当 `x` 前面是 `y`
- `x(?!y)`：先行否定断言，匹配 `x` 仅当 `x` 后面不跟着 `y`
- `(?<!y)x`：后行否定断言，匹配 `x` 仅当 `x` 前面不是 `y`
- `x|y`：匹配 `x` 或者 `y`
- `{n}`：`n` 是一个正整数，匹配前面的字符刚好出现了 `n` 次
- `{n,}`：`n` 是一个正整数，匹配前面的字符至少出现了 `n` 次
- `{n,m}`：`n` 是一个正整数，匹配前面的字符至少 `n` 次，至多 `m` 次
- `[xyz]`：字符集合。匹配方括号中的任意字符，可以使用 `-` 来指定一个字符范围。对于 `. *` 这样的特殊字符在字符集中没有特殊含义，不必进行转义（转义也是起作用的）
- `[^xyz]`：反向字符集，匹配任何没有包含在字符集中的内容，可以使用 `-` 来指定一个字符范围。
- `[\b]`：匹配一个退格，不要和 `\b` 混淆
- `\b`：匹配一个词的边界。例如字母之间的空格、`, . |` 等
- `\B`：匹配一个非单词边界
- `\d`：匹配一个数字，相当于 `[0-9]`
- `\D`：匹配一个非数字，相当于 `[^0-9]`
- `\f`：匹配一个换页符
- `\n`：匹配一个换行符
- `\r`：匹配一个回车符
- `\t`：匹配一个水平制表符
- `\v`：匹配一个垂直制表符
- `\s`：匹配一个空白字符，包括换页符、换行符、回车符、空格。相当于 `[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`
- `\S`：匹配一个非空白字符。相当于 `[^\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`
- `\w`：匹配一个单字字符（数字、字母和下划线）。相当于 `[a-zA-Z0-9_]`
- `\W`：匹配一个非单字字符。相当于 `[^a-zA-Z0-9_]`
- `\n`：在正则表达式中，返回最后的第 `n` 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。
- `\xhh`：匹配一个两位十六进制数（`\x00-\xFF`）表示的字符
- `\uhhhh`：匹配一个四位十六进制数表示的 `UTF-16` 代码单元


#### 使用正则表达式

- `exec`：在字符串中执行查找匹配的 `RegExp` 方法，它返回一个数组（未匹配到则返回 `null`）
- `test`：在字符串中测试是否匹配的 `RegExp` 方法，它返回 `true` 或 `false`
- `match`：在字符串中执行查找匹配的 `String` 方法，它返回一个数组，在未匹配到时会返回 `null`
- `matchAll`：在字符串中执行查找所有匹配的 `String` 方法，它返回一个迭代器（`iterator`），正则表达式需要指定全局符号（`g`）
- `search`：在字符串中测试匹配的 `String` 方法，它返回匹配到的位置索引，或者在失败时返回 `-1`
- `replace`：在字符串中执行查找匹配的 `String` 方法，并且使用替换字符串替换掉匹配到的子字符串，可以使用 `$1...$n` 使用匹配项，`$&` 表示整个用于匹配的原字符串
- `split`：使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 `String` 方法

#### 正则表达式标志

- `g`：全局搜索
- `i`：不区分大小写搜索
- `m`：多行搜索
- `s`：允许 `.` 匹配换行符
- `u`：使用 `unicode` 码的模式进行匹配
- `y`：执行“粘性 (`sticky`)”搜索，匹配从目标字符串的当前位置开始

#### 例子

- 匹配电话 `###-####-####`

```js
/(?:\d{3}|\(\d{3}\))([-\/\.])\d{4}\1\d{4}/g
// ?: 表示不记住匹配项
// \d{3} 表示3个数字
// \(\d{3}\) 表示 (3个数字)
// ([-\/\.]) 表示匹配 - / . 且记住匹配项
// \d{4} 四个数字
// \1 表示第一个匹配项，也就是 - / . 其中之一
```

- 匹配一个分号及紧接其前后所有可能出现的连续的不可见符号

```js
/\s*;\s*/
```

- 匹配一个或多个连续的不可见字符及其前后紧接着由一个或多个连续的基本拉丁字母表中的字母、数字和下划线组成的字符串

```js
/\w+\s+\w+/
```

- 断言

```js
const reg = /[^?!]+have(?! a lemon)[^?!]+[?!]/gi
// [^?!]+ 表示除了 ?! 以外的多个字符
// have(?! a lemon) 表示 have 后面不能有 a lemon
// [?!] 表示一个 ? 或者 !
"Do you want to have an orange? Yes, I do not want to have a lemon!".match(reg)
// [ 'Do you want to have an orange?' ]
```