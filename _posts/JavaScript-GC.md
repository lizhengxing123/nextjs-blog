---
title: '垃圾回收机制'
excerpt: '垃圾回收机制'
coverImage: '/assets/blog/javascript/js.png'
date: '2023-01-03 09:33:40'
author:
  name: 李正星
  picture: '/assets/blog/authors/zx.jpeg'
ogImage:
  url: '/assets/blog/javascript/js.png'
type: 'Javascript'
---

# 垃圾回收机制

[参考文章](https://juejin.cn/post/6981588276356317214)

`JavaScript` 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。

其基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一段时间就会自动运行。

垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。主要用两种标记策略：

- 标记清理
- 引用计数

## 标记清理

`JavaScript` 最常用的垃圾回收策略就是标记清理。

垃圾回收程序运行的时候，大致流程是这样的：

- 1、垃圾回收程序标记内存中存储的所有变量（标记的方法有很多种，比如，当变量进入上下文的时候，反转某一位；或者可以维护‘在上下文中’和‘不在上下文中’两个变量列表，可以把一个变量从一个列表转移到另一个列表）。
- 2、将所有在上下文中的变量，以及被在上下文中变量引用的变量的标记去除。在此之后，所有带标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。
- 3、随后垃圾回收程序做一次内存清理，销毁所有带标记的变量并回收它们的内存。

该策略的优点：实现十分简单，打标记无非打与不打两种情况。

缺点：

- 清除之后，由于剩余的对象内存位置是不变的，就会导致空闲内存空间是不连续的，出现内存碎片。

![内存碎片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- 由于内存碎片的出现，导致剩余空闲内存的大小不一，这就会产生内存分配问题（分配速度慢）。

内存分配有以下三种分配策略：

- 1、`First-fit`：找到大于等于`size`的块立即返回（最好的选择）
- 2、`Best-fit`：遍历整个空闲列表，返回大于等于`size`的最小分块
- 3、`Worst-fit`：遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分`size`大小，并将该部分返回（切分之后会造更多的小块，形成内存碎片）

![内存分配](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 解决方式

归根结底，标记清理的缺点就是会产生内存碎片，进而导致内存分配问题。所以，只要不产生内存碎片，就可以解决这个缺点。

**标记整理算法**可以有效的解决标记清理的缺点。其原理就是，在标记结束之后，该算法会将没带标记的对象（活着的对象）移向内存的一端，最后清理掉边界的内存（需清理的对象）。

![标记整理](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 引用计数

其基本原理就是：

- 对每个值都记录它被引用的次数
- 声明变量并给它赋一个引用值时，这个值的引用数为1
- 如果同一个值又被赋给另一个变量，那么引用数加1
- 类似的，如果保存该值引用的变量被其他值给覆盖了，那么引用数减1
- 当一个值的引用数为0时，就说明没办法再访问到这个值了，就可以安全的回收其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存

```js
const obj = {a: 1} // 引用的次数 1
const obj1 = obj // 引用的次数 2

obj = null // // 引用的次数 1
obj1 = null // // 引用的次数 0
// GC 释放其内存
```

引用计数最大的问题就是循环引用：

```js
function problem() {
  const a = {}
  const b = {}

  a.b = b
  b.a = a
}
```

在上面的 `problem` 函数中，对象 `a,b` 通过各自的属性相互引用，通过引用计数计算出这两个对象的引用数都为2。在标记清理的策略中，这不是问题，因为函数结束后，这两个对象都不在作用域，自然会被清理掉。而在引用计数策略中，这两个对象在函数结束后依然会存在，因为它们的引用数永远不会变成0。如果函数被多次调用，就会导致大量的内存永远不会被释放。

优点：

- 引用计数在每个值引用数为0时就会被回收，它可以立即回收垃圾
- 标记清理需要每隔一段时间进行一次，那么在应用程序运行过程中线程就必须暂停去执行一段时间的`GC`；另外，标记清理需要遍历堆里的活动以及非活动对象来清除，而引用计数只需要在引用时计数就可以了。

缺点：

- 它需要一个计数器，需要占很大的位置，因为我们不知道被引用数量的上限
- 无法解决循环引用无法回收的问题

## V8对GC的优化

现在大多数浏览器都是基于标记清理算法，`V8`对标记清理算法进行了优化加工处理。

### 分代式垃圾回收

正如前面所提到的，标记清理会在每次垃圾回收时检查内存中的所有对象，这样的话，对于一些大、老、存活时间长的对象和小、新、存活时间短的对象执行一个检查频率很不好。因为前者需要时间长，其不需要频繁进行清理，后者恰巧相反。

#### 新老生代

`V8` 的垃圾回收策略主要基于分代式垃圾回收机制，`V8`中将堆内存分为新生代和老生代两个区域，采用不同的垃圾回收策略管理垃圾回收。

新生代的对象为存活时间短的对象（新产生的对象），通常只支持 `1-8M` 的容量；老生代的对象是存活时间长或常驻内存的对象，是经历过新生代垃圾回收之后还存活下来的对象，容量通常比较大。

`V8` 整个内存堆的大小就是新生代加上老生代的内存。

#### 新生代垃圾回收

新生代将堆内存一分为二，一个是处于使用状态的空间，暂且称为使用区，另外一个是处于闲置状态的闲置区。

![新生代](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

新产生的对象都会放入使用区，当使用区快被写满时，就会执行一次垃圾回收操作。

当开始进行垃圾回收时，新生代垃圾回收器会对使用区内的活动对象做标记，标记完成之后将使用区中的活动对象复制到空闲区并进行排序，随后进入垃圾清理阶段，将非活动对象占用的内存空间释放掉。最后将空闲区变为使用区（里面存在复制的活动对象），使用区变为空闲区（非活动对象已被清理）。

当一个对象经过多次复制后依然存活，它将会被移动到老生代中，采用老生代垃圾回收策略进行管理。

还用另外的情况，如果复制一个对象到空闲区时，空闲区空间占用超过`25%`，那么这个对象会被直接移动到老生代空间中。设置`25%`比例的原因是：当完成回收后，空闲区变为使用区，继续进行对象内存分配，若占比过大，将会影响后续内存分配。


#### 老生代垃圾回收

由于大多数占用空间大、存活时间长的对象会被分配到老生代空间中，因此老生代的垃圾回收策略就不是新生代那样复制转换了，那样会非常耗时，且回收执行效率不高。

老生代垃圾回收策略直接采用标记清理算法。

首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素为活动对象，到达不了的则为非活动对象。

`V8` 采用标记整理算法来优化空间，其将活动对象都移动到内存一端，以解决内存碎片问题。

清除阶段直接将非活动对象占用内存释放掉。

#### 为什么需要分代式

分代式机制把一些新、小、存活时间短的内存对象作为新生代，采用一小块内存，以较高频率快速清理；另外一些老、大、存活时间长的内存对象作为老生代，使其较少接受检查。新老生代的回收机制及频率都是不同的，此机制很大程度上提高了垃圾回收机制的效率。

### 并行回收

由于 `JavaScript` 是一门单线程语言，它是运行在主线程上的，一旦垃圾回收机制开始运行，就会阻塞 `JavaScript` 脚本的执行，需要等待垃圾回收完毕后才能恢复脚本的执行，这种行为被称为全停顿。

假设一次 `GC` 需要耗费 `60ms`，那么应用程序就会停顿 `60ms`，一旦 `GC` 耗费时间过长，就会造成页面卡顿等问题。

`V8` 引入了并行回收机制，垃圾回收在主线程上执行的时候，开启多个辅助线程，同时执行同样的工作。也就是说一个人需要耗费的时间长，那么多找几个人一起干时间不就短了嘛！

![并行回收](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0eef6c0d3bd49659a564fe698d17f43~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

虽然时间是缩短了，但是仍然会占用主线程，阻塞脚本的执行。

另外，由于主线程需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也比较简单。

新生代对象空间就采用并行策略，在垃圾回收的过程中，会启动多个线程来负责新生代中垃圾回收操作。这些线程同时将内存空间中的数据移动到空闲区域，这个过程由于数据地址会发生变化，所以还需要同步更新引用这些对象的指针，此即并行回收。


### 增量标记与惰性清理

并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收有很好的优化，但是其仍然是一个全停顿式的垃圾回收策略，对于老生代来说，其中都是一些比较大的对象，如果仍采用并行回收可能会消耗大量时间。

为了减少全停顿的时间，老生代的标记从全停顿标记切换到增量标记

#### 什么是增量

增量就是将一次`GC`标记的过程，分成很多小块，每执行一小步就让应用逻辑执行一会，这样交替多次后完成一轮`GC`标记。

![增量](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e16d93c2c8414d3ab7eac55c852c678a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

这样就会产生两个问题：

- 将一次完整的`GC`标记分次执行，那么每一块`GC`标记执行完成之后如何暂停下来去执行任务程序，而后又怎么恢复呢？
- 假如在一次完整的`GC`标记分块暂停后，执行任务程序时内存标记好的对象引用关系被修改了该怎么办呢？

可以看出增量的实现要比并行复杂一点。以上两个问题的对象解决方案分别是三色标记法和写屏障。

#### 三色标记法（暂停与恢复）

老生代采用的是标记清理算法，在没有采用增量标记之前，单纯使用白色和黑色来标记数据就可以了。其标记流程为：

- 在执行一次完整的`GC`标记之前，垃圾回收器会将所有的数据置为白色
- 然后垃圾回收器会从根对象出发，将所有能访问到的对象标记为黑色
- 遍历结束之后，白色的数据对象就是待清理的垃圾对象

如果采用黑白两色标记，那么在垃圾回收器执行了一段增量回收之后，暂停去执行`JavaScript`代码，之后又继续启动垃圾回收器，这时内存中黑白两色都有，我们无法确定到底走到哪一步了。

为了解决这一问题，诞生了三色标记法，即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：

- 白色：未被标记的对象灰、黑
- 灰色：自身被标记，成员对象（该对象的引用对象）未被标记
- 黑色：自身和成员对象都被标记

![三色标记法](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b012d88c1f064eaebd0df60a9aadb85e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

由上图可见：

- 刚开始所有对象都为白色
- 从一组根对象开始，先将这组根对象标记为灰色，并推入标记工作表中
- 当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身标记为黑色，它的下一个引用对象标记为灰色
- 循环往复，直到没有可标记灰色的对象时，也就是无可达的对象了，那么剩下的白色的对象都是需要被清理的对象

采用三色标记法后我们在恢复执行的时候就好办了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如果没有灰色节点，直接进入清理阶段，如果有灰色节点，直接从灰色节点继续执行就行了。

三色标记法的标记操作可以渐进执行，而不需要每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少全停顿的时间

#### 写屏障（增量中修改引用）

![增量中修改引用](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bada1914eff449b48b5a14e53c107ff3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

来看上图中的例子：

- 在第一次增量分段中，将`A B C`三个对象都标记成黑色了
- 而后，在脚本中将对象`B`的指向由对象`C`改成了对象`D`，接着恢复执行下一次增量分段
- 这时，`C`已经没有引用关系了，但它仍为黑色，这一整轮的`GC`是不会清理`C`的
- `D`是初始的白色，按照上面所说的，没有灰色节点，就会直接进入清理阶段，`D`就会被清理掉，引用关系会被回收，这肯定是有问题的，因为我们后面可能回用到`D`

为了解决上述问题，`V8`增量回收使用写屏障机制，即一旦有黑色对象引用白色对象，该机制会强制将白色对象修改为灰色，从而保证下一次增量`GC`标记阶段可以正确标记，这个机制也被称作`强三色不变性`。

因此，在上图的例子中，`D`会被强制改为灰色。

#### 惰性清理

增量标记只是对活动对象和非活动对象进行标记，真正的清理释放内存是惰性清理。

增量标记完成后，惰性清理就开始了。如果增量标记完成后，当前的可用内存足以让我们快速的执行代码，其实是没必要立即清理内存的，可以让清理过程稍微延迟一下，可以让`js`脚本先执行，也无需一次性清理完所有非活动对象，可以按需逐一进行清理，直到所有非活动对象内存都清理完毕，后面再接着执行增量标记。

#### 增量标记与惰性清理的优缺

增量标记与惰性清理使得主线程全停顿时间大大减少，让用户与浏览器的交互过程变得更加流畅。

但是由于每个小的增量标记之间执行了`js`代码，其总暂停时间并没有减少，甚至略有增加；

另外由于堆中的对象指针可能发生了变化，需要写屏障来修改引用，这可能会降低应用程序的吞吐量（系统在单位时间内处理请求的数量）

### 并发回收

之前提到的并行回收依然会阻塞主线程，增量标记同样有增加总暂停时间和降低应用程序吞吐量两个缺点。

并发回收指的是在主线程执行`js`代码的时候，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不被挂起。

![并发回收](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bae064a3a8e481b8829c9c7aef73a06~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

并发回收的难点就在于辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不被挂起，因为它需要考虑主线程在执行`js`的时候，堆内的对象引用关系随时都有可能发生变化，这时辅助线程之前所做的或者正在做的标记都要发生改变，所以它需要额外实现一些读写锁机制来控制这一点。

### V8中的GC优化

`V8`的垃圾回收策略主要基于分代式垃圾回收机制。

对于新生代垃圾回收，使用并行回收来增加垃圾回收效率。

对于老生代垃圾回收：

- 主要使用并发标记，主线程在执行`js`脚本的时候，辅助线程也同时执行标记操作，标记操作全部由辅助线程来完成
- 标记完成之后，再执行并行清理操作，主线程在执行清理操作时，多个辅助线程也同时在执行清理操作
- 清理的任务会采用增量的方式分批在各个`js`任务之间执行

## 内存泄漏

[参考文章](https://juejin.cn/post/6984188410659340324)

并不是所有的无用对象内存都可以被回收，如果无用的对象内存没有被及时回收掉，我们叫它内存泄漏。

### 常见的内存泄漏

#### 不正当的闭包

闭包是指有权访问另一个函数作用域中变量的函数

```js
const fn = () => {
  const test = "test"
  return () => {
    console.log("child")
  }
}

fn()()
```

上面的函数就是一个闭包，但它并没有造成内存泄漏，当`fn`函数执行完之后，`test`变量就会被回收。

```js
const fn = () => {
  const test = "test"
  return () => {
    console.log(test)
    return test
  }
}

const fn1 = fn()
fn1()
```

上面的这个函数也是一个闭包，它由于在返回的函数中使用了父级作用域中的变量，所以`test`变量并不会被回收，这就造成了内存泄漏。

解决方式也很简单，就是在函数调用完成之后，把引用关系置空就可以了。

```js
fn1 = null
```

所以，不正当的使用闭包可能会导致内存泄漏。

#### 隐式全局变量

```js
const fn = () => {
  test = new Array(500).fill(1)
  this.test2 = "test2"
}
fn()
```

上述函数调用就会产生两个隐式全局变量，并且这两个全局变量不会被回收，我们应该使用严格模式来规避这种情况，或者使用完之后将变量置为`null`

#### 游离DOM引用

如果我们使用变量缓存`DOM`节点的引用，移除节点时，我们应该同步释放缓存的引用，否则游离的子树无法释放，就会造成内存泄漏。

```html
<div id="root">
  <ul id="ul">
    <li></li>
    <li></li>
    <li id="li3"></li>
    <li></li>
  </ul>
</div>
<script>
  let root = document.querySelector('#root')
  let ul = document.querySelector('#ul')
  let li3 = document.querySelector('#li3')
  
  // 由于ul变量存在，整个ul及其子元素都不能被垃圾回收
  root.removeChild(ul)
  
  // 虽然置空了ul变量，但由于li3变量引用了ul的子节点，所以ul元素依然不能垃圾回收
  ul = null
  
  // 已无变量引用，此时可以垃圾回收
  li3 = null
</script>
```

#### 遗忘的定时器

`setTimeout`、`setInterval`、`requestAnimationFrame`这三个方法在不调用清除方法的时候，回调函数里的变量无法被回收，就会造成内存泄漏。当我们不需要的时候应该及时清除。

#### 遗忘的事件监听器

在`vue`和`react`中，我们在组件加载的时候添加事件监听器，在组件销毁的时候应该及时清除事件监听器。

#### 遗忘的监听者模式

离开页面应该主动清除

#### 遗忘的Map、Set

`Map`和`Set`都是强引用，如果不主动清除引用，也可能会造成内存泄漏

#### 未清理的console输出

我们之所以能看到控制台输出，是由于浏览器保存了输出对象的信息数据引用，也正是如此，未清理的`console`如果输出了对象也可能造成内存泄漏。

我们在开发环境可以使用，在生产环境应该清除全部`console`。

## 内存三大件

- 内存泄漏：对象已经不再使用但没有被回收，内存没有被释放，即内存泄漏，需要避免让无用数据还存在引用关系，要多注意以上所说的几种常见的内存泄漏情况
- 内存膨胀：即在短时间内内存占用极速上升到达一个峰值，想要避免这种情况需要使用技术手段减少对内存的占用
- 频繁`GC`：顾名思义，就是 `GC` 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 `GC`，频繁 `GC` 同样会导致页面卡顿，想要避免的话就不能使用太多的临时变量，因为临时变量不用了就会被回收，这和我们内存泄漏中说的避免使用全局变量冲突，其实，只要把握好其中的度，不太过分就可以了