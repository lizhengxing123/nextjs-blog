---
title: '变量'
excerpt: '变量'
coverImage: '/assets/blog/go/go.webp'
date: '2023-06-19 16:53:06'
author:
  name: 李正星
  picture: '/assets/blog/authors/zx.jpeg'
ogImage:
  url: '/assets/blog/go/go.webp'
type: 'Go'
---

## 变量

### 命名规则

`Go` 语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：

**由字母、数字和下划线组成，不能以数字开头，且大小写敏感**

如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么就在当前包的所有文件中都可访问。

名字开头的大小写决定了名字在包外的可见性。如果是以大写字母开头的包级名字，那么它将是导出的，可以被外部的包访问，例如 `fmt` 包里的 `Println`。包本身的名字一般总是用小写的。

`Go` 语言的风格是尽量使用短小的名字。如果一个名字的作用域比较大，声明周期比较长，那么用长的名字会更有意义。

`Go` 语言推荐使用 **驼峰** 命名，缩略词应避免使用大小写混写的方式。例如应该使用 `escapeHTML` ，而不是 `escapeHtml`

### 声明

声明语句定义了程序的各种实体对象一级部分或全部属性。

- `var` 声明变量
- `const` 声明常量
- `func` 声明函数
- `type` 声明类型

```go
package main

import "fmt"

// 在整个包的所有源文件中都可以使用
const boilingF = 212.0

func main() {
  var b = boilingF
  var c = (f - 32) * 5 / 9 
  fmt.Println(f, c)
}
```

### 变量声明

```go
var 变量名 类型 = 表达式
```

其中 "类型" 或 "= 表达式" 可以省略一个。

如果省略的是 "类型"，那么会根据初始化表达式自动推断类型。

如果省略的是 "= 表达式"，那么将用类型对应的零值初始化该变量。
- 数值类型 -> `0`
- 布尔类型 -> `false`
- 字符串类型 -> `""`
- 接口或引用类型（包括 `slice`、指针、`map`、`chan`和函数） -> `nil`
- 数组或结构体等聚合类型 -> 每个元素或字段都是对应该类型的零值

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在 `Go` 语言中 **不存在未初始化的变量** 。

```go
var s string
fmt.Println(s) // ""
```

也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量

```go
var a, b, c int // a b c 都是 int 类型，都是 0 

var d, e, f = false, 3.2, "qw"
// d -> bool
// e -> float64
// f -> string
```

初始化表达式可以是字面量或任意表达式。

在包级别声明的变量会在 `main` 入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化

一组变量也可以通过函数的返回值初始化

```go
var f, err = os.Open(name) // os.Open 返回文件和错误
```

### 简短变量声明

在函数内部，可以使用简短变量声明语句的形式来声明和初始化变量。

以 `变量名 := 表达式` 来声明变量，变量的类型根据表达式自动推导。

```go
s := "string"
```

也可以声明和初始化一组变量

```go
i, j := true, 32
```

交换两个值

```go
i, j := j, i
```

也可以使用函数返回值来声明和初始化变量

```go
f, err := os.Open(name)
```

简短变量声明左边的变量可能并不是刚声明的最新变量，如果有 **一些** 已经在相同的词法作用域中声明过了，那么对这些已经声明过的变量就只有赋值行为了。

```go
in, err := os.Open(name)

// err 被重新赋值
out, err := os.Create(name)
```

简短变量语句至少要声明 **一个** 新的变量，否则会报错 `no new variables`

```go
in, err := os.Open(name)

// No new variables on the left side of ':='
in, err := os.Create(name)
```

### 指针

一个变量对应一个保存了变量类型值的内存空间。

一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是每一个变量必然有对应的内存地址。通过指针，我们可以直接读取或者修改对应变量的值，而不需要知道该变量的名字。

使用 `&变量` 来获取变量的内存地址

```go
a := 12

fmt.Println(a, &a)
// 12 0xc0000260a0
```

指针的类型是 `*类型`

```go
// p 的类型是 *int
p := &a
```

我们可以使用 `*指针` 来获取指针变量存储的值

```go
fmt.Println(p, &p, *p)
// 0xc0000260a0 0xc000012030 12
```

通过修改 `*指针` 的值，进而修改指针所指向变量的值

```go
*p = 32

fmt.Println(a, &a)
// 32 0xc0000a6020

fmt.Println(p, &p, *p)
// 0xc0000a6020 0xc0000ac020 32
```

> 对于聚合类型的每个成员（比如结构体的每个字段或者数组的每个元素）也都是对应一个变量，因此可以被取值。

任何类型的指针的零值都是 `nil`。如果指针指向某个有效变量，那么 `p != nil` 为真。

指针之间也可以进行相等测试，只有它们指向同一个变量或全部都是 `nil` 的时候才相等

```go
var i, j int

fmt.Println(&i, &j)
// 0xc00010e018 0xc00010e030

fmt.Println(&i == &i, &i == &j, &j == nil)
// true false false
```

指针可以作为函数的返回值

```go
func f2() *int {
	i := 20
	return &i
}

p := f2()

fmt.Println(p, *p)
// 0xc000070f58 20

fmt.Println(f2() == f2())
// false
```

指针也可以作为函数的参数

```go
func f3(p *int) int {
  // 只是增加 p 指针所指向变量的值，并不改变 p 指针
	*p++
	return *p
}

x := 3
f3(&x) // x 的值变为 4

fmt.Println(f3(&x)) // x 的值变为 5
fmt.Println(x) // x 的值变为 5
```

指针是实现标准库 `flag` 包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量就是指针。

```go
package main

import (
  "flag"
  "fmt"
)

// 设置命令行参数
// 第一个参数是命令行参数的名字
// 第二个参数是命令行参数的默认值
// 第三个参数是命令行参数的描述信息

// 布尔类型的命令行标志参数
var n = flag.Bool("n", false, "omit trailing newline")
// 字符串类型的命令行标志参数
var s = flag.String("s", " ", "separator")

func main() {
  // 必须在使用命令行标志参数前调用 Parse 函数
  // 用以更新每个命令行标志参数对应变量的值，之前是默认值
  flag.Parse()
  
  // 对于非命令行标志参数的普通命令行参数可以使用 Args 函数获取
  fmt.Println(flag.Args())

  // 获取命令行标志参数的值
  fmt.Println(*n, *s)
}
```

打包测试

```go
go build test.go   

./test -n=true -s=abc a b c 

[a b c] // 普通命令行参数

true abc // 命令行标志参数
```

### new 函数

表达式 `new(T)` 将创建一个 `T` 类型的匿名变量，初始化为 `T` 类型的零值，然后返回变量地址，返回的指针类型为 `*T`

```go
p = new(int)
fmt.Println(*p) // 0

*p = 2 // 修改匿名变量的值
fmt.Println(*p)
```

`new` 函数类似一个语法糖，其不需要声明临时变量

```go
// 这两个函数有着相同的行为
func newInt() *int {
  return new(int)
}

func newInt() *int {
  var i int
  return &i
}
```

每次调用 `new` 函数都是返回一个新的变量地址

```go
a := new(int)
b := new(int)

fmt.Println(a == b) // false
```

由于 `new` 是一个预定义的名字，因此可以覆盖它

```go
// 在这个函数里面就不可以使用 new 函数了
// 因为它现在是 int 类型
func delta(old, new int) int {
  return new - old
}
```

### 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。

对于包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。

相比之下，局部变量的生命周期是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。

函数的参数变量和返回值变量都是局部变量，它们在每次函数被调用的时候创建。

```go
for t := 0.0; t < cycles*2*math.Pi; t += res {

    x := math.Sin(t)
    y := math.Sin(t*freq + phase)

    img.SetColorIndex(
        size+int(x*size+0.5), size+int(y*size+0.5),
        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
    )               // 小括弧另起一行缩进，和大括弧的风格保存一致
}
```

每次循环开始的时候创建临时变量 `t`，然后在循环迭代中创建临时变量 `x` 和 `y`。

`Go` 语言的自动垃圾收集器是如何知道一个变量何时被回收呢？其基本实现思路是：

从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。
如果不存在这样的访问路径，则说明该变量是不可达的，也就是说它是否存在不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回后依然存在。

```go
var g *int

func f() {
  var i int
  i = 2
  g = &i
}

func g() {
  y = new(int)
  *y = 2
}
```

`f` 函数 `i` 变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的 `g` 变量找到，虽然它是在函数内部定义的。用 `Go` 语言的术语来说，这个 `i` 变量从 `f` 函数中逃逸了。

相反，当 `g` 函数返回后，变量 `*y` 是不可达的，也就是说会被马上回收。因此 `*y` 变量并没有从 `g` 函数中逃逸，编译器可以选择在栈上分配 `*y` 的存储空间，也可以在堆上分配，然后由 `Go` 语言的 `GC` 回收这个变量的内存空间。

逃逸的变量需要额外分配内存，同时对性能的优化可能产生细微的影响。