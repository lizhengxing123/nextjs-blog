---
title: '赋值'
excerpt: '赋值'
coverImage: '/assets/blog/go/go.webp'
date: '2023-06-20 21:33:54'
author:
  name: 李正星
  picture: '/assets/blog/authors/zx.jpeg'
ogImage:
  url: '/assets/blog/go/go.webp'
type: 'Go'
---

## 赋值

使用赋值语句可以更新一个变量的值

```go
// 命名变量赋值
x = 1

// 通过指针间接赋值
*p = true

// 结构体字段赋值
person.name = "lzx"

// 数组、slice 或 map 的元素赋值
count[x] = count[x] * scale
```

特定的二元算术运算符和赋值语句的复合操作有简洁形式，`*=`、`/=`、`+=`、`-=` 

```go
count[x] *= scale
```

数值变量也可以使用 `++` 递增和 `--` 递减语句

> 自增和自减是语句而不是表达式，因此 `x = i++` 之类的表达式是错误的

```go
v := 1

// v += 1
v++

// v -= 1
v--
```

### 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后在统一更新左边变量的值。

交换两个变量的值

```go
x, y = y, x

a[i], a[j] = a[j], a[i]
```

计算两个整数的最大公约数

```go
func gcd(x, y int) int {

  for y != 0 {
    x, y = y, x%y
  }

  return x
}
```

计算斐波那契数列的第 `N` 个数

```go
func fib(n int) int {

  x, y := 0, 1
  
  for i := 0; i < n; i++ {
    x, y = y, x+y
  }

  return x
}
```

有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边时，左边的变量数目必须和右边一致

```go
f, err = os.Open(filename)
```

如果 `map` 查找、类型断言或通道接收出现在赋值语句的右边，它们都可能产生会两个结果，有一个额外的布尔结果表示操作是否成功。

```go
// map 查找
v, ok = m[key]

// 类型断言
v, ok = x.(T)

// 通道接收
v, ok = <-ch
```

`map` 查找、类型断言或通道接收也有可能产生一个结果，`map` 查找失败时返回零值，类型断言失败时发送运行时 `panic` 异常，通道接收失败时会返回零值（阻塞不算失败）

```go
// map 查找，失败时返回零值
v = m[key]

// 类型断言，失败时发送运行时 panic 异常
v = x.(T)

// 通道接收，失败时会返回零值，阻塞不算失败
v = <-ch
```

可以使用下划线空白值丢弃不需要的值

```go
// 丢弃字节数
_, err = io.Copy(dst, src)

// 只检测类型，忽略具体值
_, ok = x.(T)
```

### 可赋值性

赋值语句是显式的赋值形式。还有其他隐式的赋值行为：函数调用会隐式的将调用参数的值赋值给函数的参数变量；一个返回语句会隐式的将返回操作的值赋值给结果变量；一个复合类型的字面量也会产生赋值行为

```go
medals := []string{"gold", "silver", "bronze"}

// 隐式赋值，相当于
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"
```

`map` 和 `chan` 的元素，也有类似的隐式赋值行为。

可赋值性的规则是：类型必须匹配，`nil` 可以赋值给任何指针或引用类型的变量。常量有更灵活的赋值规则，这样可以避免不必要的显式类型转换。

对于两个值是否可以用 `==` 或 `!=` 进行相等比较的能力也和可赋值能力有关：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。