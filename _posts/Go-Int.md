---
title: '基础数据类型-整型'
excerpt: '基础数据类型-整型'
coverImage: '/assets/blog/go/basicDataType.webp'
date: '2023-06-27 16:55:37'
author:
  name: 李正星
  picture: '/assets/blog/authors/zx.jpeg'
ogImage:
  url: '/assets/blog/go/basicDataType.webp'
type: 'Go'
---

## 基础数据类型-整型

`Go` 语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。

### 整型分类

`Go` 语言提供了 `int8`、`int16`、`int32` 和 `int64` 四种有符号整数类型以及 `uint8`、`uint16`、`uint32` 和 `uint64` 四种无符号整数类型。其中 `8`、`16`、`32` 和 `64` 表示 `bit` 大小。

> 有符号整型的范围是 `-2^(n-1)` 至 `2^(n-1) - 1`
> 
> 无符号整型的范围是 `0` 至 `2^(n-1)`

- `int8`：有符号 8 位整型，[-128, 127]
- `int16`：有符号 16 位整型，[-32768, 32767]
- `int32`：有符号 32 位整型，[-2147483648, 2147483647]
- `int64`：有符号 64 位整型，[-9223372036854775808, 9223372036854775807]
- `uint8`：无符号 8 位整型，[0, 128]
- `uint16`：无符号 16 位整型，[0, 32768]
- `uint32`：无符号 32 位整型，[0, 2147483648]
- `uint64`：无符号 64 位整型，[0, 9223372036854775808]

另外可以直接使用 `int` 和 `uint` 两种整数类型。这两种类型都有同样的大小，`32` 或 `64` `bit`。一般对应特定 `CPU` 平台机器字大小。

`Unicode` 字符 `rune` 类型是和 `int32` 等价的类型，通常用于表示一个 `Unicode` 码点。

同样，`byte` 也是与 `uint8` 等价的类型，`byte` 类型一般用于强调数值是一个原始的数据而不是一个小的整数。

还有一种无符号整数类型 `uintptr`，没有指定具体的位数大小，但是足以容纳指针。该类型只有在底层编程时才需要。

> 不管它们的具体大小，`int` 、 `uint` 和 `uintptr` 时不同类型的兄弟类型。
> 其中 `int` 和 `int32` 也是不同的类型，即使 `int` 的大小也是 `32bit`。
> 在需要将 `int` 当作 `int32` 类型处理的时候，我们需要进行显示的类型转换操作。


### 二元运算符

```go
/**
按照优先级递减的顺序排列：

*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||

*/
```

其中同一行的优先级相同，使用左优先结合规则。使用括号可以明确优先顺序，也可以提升优先级。

对于前两行的运算符，可以与赋值相结合，比如 `+=`、`*=`，用于简化赋值操作。

算数运算符 `+`、`-`、`*`、`/` 可以适用于整数、浮点数和复数。

取模运算符 `%` 只适用于整数间的运算，其符号与被取模数（`%` 前面的数）的符号总是一致的

```go
fmt.Println(-5 % -3) // -2
fmt.Println(-5 % 3) // -2

fmt.Println(5 % -3) // 2
fmt.Println(5 % 3) // 2
```

除法运算符 `/` 的行为依赖于操作数是否全为整数，整数除法会向着 `0` 方向截断余数

```go
fmt.Println(-5 / 3) // -1
fmt.Println(-5.0 / 3.0) // -1.6666666666666667
fmt.Println(6 / 3) // 2
```

计算结果溢出，超出高位的 `bit` 位部分将被丢弃

```go
var u uint8 = 255
fmt.Println(u) // 255
fmt.Println(u + 1) // 0
fmt.Println(u + 2) // 1

var i int8 = 127
fmt.Println(i) // 127
fmt.Println(i + 1) // -128
fmt.Println(i + 2) // -127

/**
总结：
  超出范围会循环，重新从最小数往上加
*/
```

#### 比较运算符

比较运算符的结果是布尔类型，两个相同类型的值可以用 `==` 和 `!=` 进行比较。此外，整数、浮点数和字符串可以根据比较结果排序。

#### 加减

对于整数来说，`+x` 是 `0 + x` 的缩写，`-x` 是 `0 - x` 的缩写

对于浮点数和复数， `+x` 就是是 `x`，`-x` 则是 `x` 的负数

#### 位运算符

```go
&      按位与 AND
|      按位或 OR
^      用作二元运算符是按位异或 XOR，用于一元运算符是按位非
&^     位清空 (AND NOT) x &^ y，如果 y 对应位为 1，则结果对应位为 0，否则结果对应位的值是 x 对应位的值
<<     左移 x << y = x * 2 ** y
>>     右移 x >> y = x / 2 ** y
```

```go
var x uint8 = 1<<1 | 1<<5
var y uint8 = 1<<1 | 1<<2

fmt.Println(x, y) // 34 6
/**
1 << 1 ---> 1 * 2 ** 1 = 2
1 << 5 ---> 1 * 2 ** 5 = 32
1 << 2 ---> 1 * 2 ** 2 = 4

2      ---> 0 0 0 0 0 0 1 0
32     ---> 0 0 1 0 0 0 0 0
4      ---> 0 0 0 0 0 1 0 0

2 | 32 ---> 0 0 1 0 0 0 1 0 = 34
2 | 4  ---> 0 0 0 0 0 1 1 0 = 6
*/

fmt.Println(x&y) // 2
fmt.Println(x|y) // 38
fmt.Println(x^y) // 36
fmt.Println(x&^y) // 32
/**
34      ---> 0 0 1 0 0 0 1 0
6       ---> 0 0 0 0 0 1 1 0

34 & 6  ---> 0 0 0 0 0 0 1 0 = 2
34 | 6  ---> 0 0 1 0 0 1 1 0 = 38
34 ^ 6  ---> 0 0 1 0 0 1 0 0 = 36
34 &^ 6 ---> 0 0 1 0 0 0 0 0 = 32
*/
```

任何大小的整数字面值都可以用以 `0` 开始的八进制格式书写，例如 `0666`。或用以 `0x, 0X` 开头的十六进制书写，例如 `0xdeadbeef`，十六进制数字可以用大写或小写字母。

八进制数据常用于 `POSIX` 操作系统上的文件权限访问标志，十六进制更强调数字值的 `bit` 位模式。

当使用 `fmt` 包打印时，可以使用 `%d`、`%o`、`%x` 控制输出的进制格式

```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"

x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]o %#[1]x %#[1]X\n", x)
// 3735928559 deadbeef 033653337357 0xdeadbeef 0XDEADBEEF
```

`%` 后面的 `[1]` 表示使用第一个操作数，`#` 表示在用 `%o`、`%x`、`%X` 输出时加上 `0`、`0x`、`0X` 前缀

```go
ascii := 'a'
unicode := '国'
newline := '\n'

fmt.Printf("%d %[1]c %[1]q\n", ascii) // 97 a 'a'
fmt.Printf("%d %[1]c %[1]q\n", unicode) // 22269 国 '国'
fmt.Printf("%d %[1]q\n", newline) // 10 '\n'
```